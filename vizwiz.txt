VizWiz Visualizer Plugin Template

This header documents the interface needed to create custom visualizers for VizWiz.
Copy this template and implement the required methods to create your own visualizer.

REQUIRED METHODS:
================

constructor()
  - Initialize your visualizer properties
  - Set up mutation settings, color schemes, etc.
  - Define animationId, analyser, dataArray, ctx, canvas, elements properties

init(elements)
  - Called once when visualizer is first created
  - elements: Object containing all UI elements (canvas, buttons, etc.)
  - Use this to build settings panel: this.buildVisualizerSettings()

startVisualization(analyser, dataArray, ctx, canvas)
  - Called when audio playback starts
  - analyser: Web Audio API AnalyserNode for frequency data
  - dataArray: Uint8Array buffer for frequency data
  - ctx: 2D canvas rendering context
  - canvas: HTML canvas element
  - Start your animation loop here

stopVisualization()
  - Called when audio playback stops
  - Cancel animation frames, clean up resources
  - Remove 'playing' class from trackInfo element if needed

OPTIONAL METHODS:
=================

animate()
  - Main animation loop method
  - Call requestAnimationFrame to continue loop
  - Get frequency data: analyser.getByteFrequencyData(dataArray)
  - Handle mutations if enabled
  - Call render method

render(ctx, dataArray, width, height) or render()
  - Draw your visualization to the canvas
  - Use frequency data to drive visual effects

onCanvasResize(width, height)
  - Called when canvas size changes
  - Update any size-dependent calculations

toggleSettings() / closeSettings()
  - Show/hide the settings panel
  - Default implementation: this.elements.settingsPanel.classList.toggle('hidden')

SETTINGS SYSTEM:
================

static getSettingsSchema()
  - Return object describing available settings
  - Format: { name: 'Visualizer Name', settings: { ... } }
  - Setting types: 'range', 'checkbox', 'select'
  - Range: { type: 'range', label: 'Speed', min: 0.1, max: 3.0, default: 1.0, step: 0.1, unit: 'x' }
  - Checkbox: { type: 'checkbox', label: 'Enable Feature', default: true }
  - Select: { type: 'select', label: 'Mode', options: [{value: 'mode1', label: 'Mode 1'}], default: 'mode1' }

setSetting(key, value)
  - Called when user changes a setting
  - Implement switch statement to handle each setting key
  - Update internal properties and rebuild if needed

MUTATION SYSTEM (OPTIONAL):
============================

static getMutationSettings()
  - Return object describing which settings can be mutated
  - Format: { settingKey: { probability: 0.5, values: [...] or range: {min, max}, step: 0.1 } }
  - probability: 0.0-1.0 chance of mutation per cycle
  - values: Array of possible values to randomly select
  - range: {min, max} for numeric ranges, optional step for rounding

mutateSettings()
  - Called periodically when mutation mode is enabled
  - Use getMutationSettings() to randomly change properties
  - Call updateUIControl(key, value, true) to update UI with highlight

updateUIControl(key, newValue, highlight = false)
  - Update UI control to show current value
  - highlight: true to show mutation visual feedback

highlightMutatedControl(element, key)
  - Add visual feedback when setting is mutated
  - Creates brief flash and dice emoji indicator

resetVisualizerSettings()
  - Reset all settings to defaults
  - Update UI controls to match
  - Disable mutation mode

REQUIRED PROPERTIES:
====================

this.animationId = null              // For requestAnimationFrame
this.analyser = null                 // Web Audio analyser node
this.dataArray = null                // Frequency data buffer
this.ctx = null                      // Canvas 2D context
this.canvas = null                   // Canvas element
this.elements = null                 // UI elements object
this.mutationEnabled = false         // Mutation mode state
this.mutationTimer = 0               // Mutation timing counter
this.mutationInterval = 200          // Frames between mutations

HELPER METHODS TO IMPLEMENT:
============================

buildVisualizerSettings()
  - Create settings UI from getSettingsSchema()
  - Add event listeners for controls
  - Call from init() method

createSettingItem(key, setting)
  - Create individual setting UI element
  - Handle range, checkbox, select types
  - Add change event listeners

REGISTRATION:
=============

At the end of your file, register the visualizer:

if (window.VisualizerRegistry) {
    window.VisualizerRegistry.register('myvis', 'My Awesome Visualizer', MyVisualizerClass);
} else {
    // Fallback for backward compatibility
    window.MyVisualizerClass = MyVisualizerClass;
}

EXAMPLE MINIMAL VISUALIZER:
===========================

class SimpleVisualizer {
    constructor() {
        this.animationId = null;
        this.analyser = null;
        this.dataArray = null;
        this.ctx = null;
        this.canvas = null;
        this.elements = null;
        this.color = '#ff0000';
    }

    init(elements) {
        this.elements = elements;
        this.buildVisualizerSettings();
    }

    startVisualization(analyser, dataArray, ctx, canvas) {
        this.analyser = analyser;
        this.dataArray = dataArray;
        this.ctx = ctx;
        this.canvas = canvas;
        if (!this.animationId) this.animate();
    }

    stopVisualization() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }

    animate() {
        this.animationId = requestAnimationFrame(() => this.animate());
        if (this.analyser && this.dataArray) {
            this.analyser.getByteFrequencyData(this.dataArray);
            this.render();
        }
    }

    render() {
        const width = this.canvas.width / devicePixelRatio;
        const height = this.canvas.height / devicePixelRatio;
        
        // Clear canvas
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, width, height);
        
        // Draw something based on audio data
        this.ctx.fillStyle = this.color;
        const average = this.dataArray.reduce((a, b) => a + b) / this.dataArray.length;
        const radius = (average / 255) * 100;
        this.ctx.beginPath();
        this.ctx.arc(width/2, height/2, radius, 0, Math.PI * 2);
        this.ctx.fill();
    }

    static getSettingsSchema() {
        return {
            name: 'Simple Visualizer',
            settings: {
                color: {
                    type: 'select',
                    label: 'Color',
                    options: [
                        { value: '#ff0000', label: 'Red' },
                        { value: '#00ff00', label: 'Green' },
                        { value: '#0000ff', label: 'Blue' }
                    ],
                    default: '#ff0000'
                }
            }
        };
    }

    setSetting(key, value) {
        if (key === 'color') this.color = value;
    }

    // ... implement other required methods ...
}

// Register the visualizer
if (window.VisualizerRegistry) {
    window.VisualizerRegistry.register('simple', 'Simple Circle', SimpleVisualizer);
}

TIPS:
=====

- Use devicePixelRatio for high-DPI displays: canvas.width / devicePixelRatio
- Audio data is in dataArray as values 0-255
- Use requestAnimationFrame for smooth 60fps animation
- Implement mutation system for dynamic, evolving visuals
- Cache expensive calculations when possible
- Test on different screen sizes and audio types
- Use ctx.save() and ctx.restore() for complex transformations
- Consider performance - avoid creating objects in animation loops
