VizWiz Visualizer Plugin Template

This header documents the interface needed to create custom visualizers for VizWiz.
Copy this template and implement the required methods to create your own visualizer.

REQUIRED METHODS
================

constructor()
  - Initialize your visualizer properties
  - Set up mutation settings, color schemes, etc.
  - Define animationId, analyser, dataArray, ctx, canvas, elements properties

init(elements)
  - Called once when visualizer is first created
  - elements: Object containing all UI elements (canvas, buttons, etc.)
  - Use this to build settings panel: this.buildVisualizerSettings()

startVisualization(analyser, dataArray, ctx, canvas)
  - Called when audio playback starts
  - analyser: Web Audio API AnalyserNode for frequency data
  - dataArray: Uint8Array buffer for frequency data
  - ctx: 2D canvas rendering context
  - canvas: HTML canvas element
  - Start your animation loop here

stopVisualization()
  - Called when audio playback stops
  - Cancel animation frames, clean up resources
  - Remove 'playing' class from trackInfo element if needed

OPTIONAL BUT LIKELY NEEDED BY YOUR VISUALIZER
=============================================

animate()
  - Main animation loop method
  - Call requestAnimationFrame to continue loop
  - Get frequency data: analyser.getByteFrequencyData(dataArray)
  - Handle mutations if enabled
  - Call render method

render(ctx, dataArray, width, height) or render()
  - Draw your visualization to the canvas
  - Use frequency data to drive visual effects

onCanvasResize(width, height)
  - Called when canvas size changes
  - Update any size-dependent calculations

toggleSettings() / closeSettings()
  - Show/hide the settings panel
  - Default implementation: this.elements.settingsPanel.classList.toggle('hidden')

SETTINGS SYSTEM:
================

static getSettingsSchema()
  - Return object describing available settings
  - Format: { name: 'Visualizer Name', settings: { ... } }
  - Setting types: 'range', 'checkbox', 'select'
  - Range: { type: 'range', label: 'Speed', min: 0.1, max: 3.0, default: 1.0, step: 0.1, unit: 'x' }
  - Checkbox: { type: 'checkbox', label: 'Enable Feature', default: true }
  - Select: { type: 'select', label: 'Mode', options: [{value: 'mode1', label: 'Mode 1'}], default: 'mode1' }

setSetting(key, value)
  - Called when user changes a setting
  - Implement switch statement to handle each setting key
  - Update internal properties and rebuild if needed

MUTATION SYSTEM
===============

static getMutationSettings()
  - Return object describing which settings can be mutated
  - Format: { settingKey: { probability: 0.5, values: [...] or range: {min, max}, step: 0.1 } }
  - probability: 0.0-1.0 chance of mutation per cycle
  - values: Array of possible values to randomly select
  - range: {min, max} for numeric ranges, optional step for rounding

mutateSettings()
  - Just call window.VisualizerRegistry.applyMutations(this)
  - The registry handles all mutation logic and UI updates automatically

updateUIControl(key, newValue, highlight = false)
  - Just call window.VisualizerRegistry.updateUIControl(this, key, newValue, highlight)
  - Automatically handles number formatting and UI updates

resetVisualizerSettings()
  - Just call window.VisualizerRegistry.resetToDefaults(this)
  - Resets all settings and updates UI controls

highlightMutatedControl(element, key)
  - Add visual feedback when setting is mutated
  - Creates brief flash and dice emoji indicator
  - This method still needs to be implemented in each visualizer

REQUIRED PROPERTIES:
====================

this.animationId = null              // For requestAnimationFrame
this.analyser = null                 // Web Audio analyser node
this.dataArray = null                // Frequency data buffer
this.ctx = null                      // Canvas 2D context
this.canvas = null                   // Canvas element
this.elements = null                 // UI elements object
this.mutationEnabled = false         // Mutation mode state
this.mutationTimer = 0               // Mutation timing counter
this.mutationInterval = 200          // Frames between mutations

HELPER METHODS TO IMPLEMENT:
============================

buildVisualizerSettings()
  - Create settings UI from getSettingsSchema()
  - Add event listeners for controls
  - Call from init() method

createSettingItem(key, setting)
  - Create individual setting UI element
  - Handle range, checkbox, select types
  - Add change event listeners

REGISTRATION:
=============

At the end of your file, register the visualizer:

if (window.VisualizerRegistry) {
    window.VisualizerRegistry.register('myvis', 'My Awesome Visualizer', MyVisualizerClass);
} else {
    // Fallback for backward compatibility
    window.MyVisualizerClass = MyVisualizerClass;
}

EXAMPLE MINIMAL VISUALIZER REQUIRED FEATURES
============================================

class SimpleVisualizer {
    constructor() {
        this.animationId = null;
        this.analyser = null;
        this.dataArray = null;
        this.ctx = null;
        this.canvas = null;
        this.elements = null;
        this.color = '#ff0000';
        this.mutationEnabled = false;
        this.mutationTimer = 0;
        this.mutationInterval = 200;
    }

    init(elements) {
        this.elements = elements;
        this.buildVisualizerSettings();
    }

    startVisualization(analyser, dataArray, ctx, canvas) {
        this.analyser = analyser;
        this.dataArray = dataArray;
        this.ctx = ctx;
        this.canvas = canvas;
        if (!this.animationId) this.animate();
    }

    stopVisualization() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }

    animate() {
        this.animationId = requestAnimationFrame(() => this.animate());
        if (this.analyser && this.dataArray) {
            this.analyser.getByteFrequencyData(this.dataArray);
            
            // Handle mutations (simplified!)
            if (this.mutationEnabled) {
                this.mutationTimer++;
                if (this.mutationTimer >= this.mutationInterval) {
                    this.mutateSettings();
                    this.mutationTimer = 0;
                }
            }
            
            this.render();
        }
    }

    render() {
        const width = this.canvas.width / devicePixelRatio;
        const height = this.canvas.height / devicePixelRatio;
        
        // Clear canvas
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, width, height);
        
        // Draw something based on audio data
        this.ctx.fillStyle = this.color;
        const average = this.dataArray.reduce((a, b) => a + b) / this.dataArray.length;
        const radius = (average / 255) * 100;
        this.ctx.beginPath();
        this.ctx.arc(width/2, height/2, radius, 0, Math.PI * 2);
        this.ctx.fill();
    }

    static getSettingsSchema() {
        return {
            name: 'Simple Visualizer',
            settings: {
                color: {
                    type: 'select',
                    label: 'Color',
                    options: [
                        { value: '#ff0000', label: 'Red' },
                        { value: '#00ff00', label: 'Green' },
                        { value: '#0000ff', label: 'Blue' }
                    ],
                    default: '#ff0000'
                },
                mutateMode: {
                    type: 'checkbox',
                    label: 'Mutate Colors',
                    default: false
                }
            }
        };
    }

    static getMutationSettings() {
        return {
            color: {
                probability: 0.6,
                values: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff']
            }
        };
    }

    setSetting(key, value) {
        if (key === 'color') {
            this.color = value;
        }
    }

    // Delegate to the registry!
    mutateSettings() {
        window.VisualizerRegistry.applyMutations(this);
    }

    updateUIControl(key, newValue, highlight = false) {
        window.VisualizerRegistry.updateUIControl(this, key, newValue, highlight);
    }

    resetVisualizerSettings() {
        window.VisualizerRegistry.resetToDefaults(this);
    }

    // Implement this for visual feedback of mutations
    highlightMutatedControl(element, key) {
        const settingItem = element.closest('.setting-item');
        if (!settingItem) return;
        
        settingItem.style.background = 'rgba(99, 102, 241, 0.3)';
        settingItem.style.borderRadius = '4px';
        settingItem.style.transition = 'all 0.3s ease';
        
        setTimeout(() => {
            settingItem.style.background = '';
        }, 1000);
    }

    // REQUIRED UI integration methods (must be implemented in every visualizer)
    // These are called directly by vizwiz.js. Your visualizer WILL break if omitted
    // Rewite according to your implementation
    buildVisualizerSettings() { /* ... */ }
    createSettingItem(key, setting) { /* ... */ }
    toggleSettings() { /* ... */ }
    closeSettings() { /* ... */ }
    onCanvasResize(width, height) { /* ... */ }
}

// Register the visualizer
if (window.VisualizerRegistry) {
    window.VisualizerRegistry.register('simple', 'Simple Circle', SimpleVisualizer);
}

AVAILABLE UTILITIES:
====================

The VisualizerRegistry provides these utilities to simplify development:

window.VisualizerRegistry.cleanValue(value, step)
  - Automatically rounds floating point numbers to appropriate precision
  - Based on the step value from settings schema

window.VisualizerRegistry.updateUIControl(visualizer, key, newValue, highlight)
  - Updates UI controls with properly formatted values
  - Handles range sliders, checkboxes, and select elements
  - Automatically applies number cleaning for range inputs

window.VisualizerRegistry.applyMutations(visualizer)
  - Applies random mutations based on getMutationSettings()
  - Automatically updates UI controls with visual feedback
  - Handles all the mutation logic and logging

window.VisualizerRegistry.resetToDefaults(visualizer)
  - Resets all settings to their default values
  - Updates all UI controls to match
  - Disables mutation mode

TIPS:
=====

- Use devicePixelRatio for high-DPI displays: canvas.width / devicePixelRatio
- Audio data is in dataArray as values 0-255
- Use requestAnimationFrame for smooth 60fps animation
- Implement mutation system for dynamic, evolving visuals
- Cache expensive calculations when possible
- Test on different screen sizes and audio types
- Use ctx.save() and ctx.restore() for complex transformations
- Consider performance - avoid creating objects in animation loops
- Take advantage of the centralized utilities to reduce boilerplate code
- Number formatting and UI updates are handled automatically by the registry
